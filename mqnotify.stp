%{
#include <linux/fdtable.h>
#include <net/sock.h>

struct netlink_sock {
        /* struct sock has to be the first member of netlink_sock */
        struct sock		sk;
        u32			portid;
        u32			dst_portid;
        u32			dst_group;
        u32			flags;
        u32			subscriptions;
        u32			ngroups;
        unsigned long		*groups;
        unsigned long		state;
        size_t			max_recvmsg_len;
        wait_queue_head_t	wait;
        bool			cb_running;
        struct netlink_callback	cb;
        struct mutex		*cb_mutex;
        struct mutex		cb_def_mutex;
        void			(*netlink_rcv)(struct sk_buff *skb);
        int			(*netlink_bind)(int group);
        void			(*netlink_unbind)(int group);
        struct module		*module;
    }; 
%}

global sock_ptr = 0;


probe kernel.function ("netlink_attachskb")
{
    if (execname() == "exploit")
    {
        printf("(%d-%d) [netlink] ==>> netlink_attachskb (%s)\n", pid(), tid(), $$parms)

    }
}

probe syscall.mq_notify
{
	if ( execname() == "exploit" )
	{
		printf("\n\n(%d-%d) [SYSCALL] ==>> mq_notify (%s)\n", pid(), tid(), argstr)
	}
}

probe syscall.mq_notify.return
{
	if ( execname() == "exploit" )
	{
		printf("(%d-%d) [SYSCALL] <<== mq_notify = %d \n\n\n", pid(), tid(), $return)
	}
}

probe kernel.function("__fdget")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [vsf] ==>> fdget(%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("__fdget").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [vsf] <<== fdget = %x \n", pid(), tid(), $return)
    }
}

probe kernel.function("copy_from_user")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [uland] ==>> copy_from_user()\n", pid(), tid())
    }
}

probe kernel.function("__alloc_skb")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [skb] ==>> alloc_skb (%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("skb_put")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [skb] ==>> skb_put  (%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("skb_put").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [skb] <<== skb_put = %x \n", pid(), tid(), $return)
    }
}

probe kernel.function("netlink_getsockbyfilp")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] ==>> netlink_getsockbyfilp  (%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("netlink_getsockbyfilp").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] <<== netlink_getsockbyfilp  = %x \n", pid(), tid(), $return)
        sock_ptr = $return;
    }
}

probe kernel.function("netlink_attachskb").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] <<== netlink_attachskb  = %x \n", pid(), tid(), $return)
    }
}

probe kernel.function("netlink_detachskb")
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] ==>> netlink_detachskb   (%s)\n", pid(), tid(), $$parms)
    }
}

probe kernel.function("netlink_detachskb").return
{
    if ( execname() == "exploit" )
    {
        printf("(%d-%d) [netlink] <<== netlink_detachskb \n", pid(), tid())
    }
}















